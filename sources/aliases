#!/usr/bin/env bash

# dotfiles directory shorcut
alias dotfiles="cd ${HOME}/code/dotfiles"

# Preferred 'mv' implementation
alias mv='mv -iv'
# Preferred 'mkdir' implementation
alias mkdir='mkdir -pv'
# Preferred 'less' implementation
alias less='less -FSRXc'
# Go back 1 directory level (for fast typers)
alias cd..='cd ../'
# Go back 1 directory level
alias ..='cd ../'
# Clear terminal display
alias c='clear'
# Find executables
alias which='type -all'
# Echo all executable Paths
alias path='echo -e ${PATH//:/\\n}'
# Display bash options settings
alias show_options='shopt'
# Restore terminal settings when screwed up
alias fix_stty='stty sane'
# Make tab-completion case-insensitive
alias cic='set completion-ignore-case On'
# Restore ssh-agent in tmux
alias fix_ssh='eval $(tmux showenv -s SSH_AUTH_SOCK)'

# Makes new Dir and jumps inside
mcd () { mkdir -p "$1" && cd "$1"; }

# Full Recursive Directory Listing
alias lr='ls -R | grep ":$" | sed -e '\''s/:$//'\'' -e '\''s/[^-][^\/]*\//--/g'\'' -e '\''s/^/   /'\'' -e '\''s/-/|/'\'' | less'

# Count of non-hidden files in current dir
alias numFiles='echo $(ls -1 | wc -l)'

# To create a ZIP archive of a folder
zipf () { zip -r "$1".zip "$1" ; }
# Extract most know archives with one command
extract () {
    if [ -f $1 ] ; then
      case $1 in
        *.tar.bz2)   tar xjf $1     ;;
        *.tar.gz)    tar xzf $1     ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar)       unrar e $1     ;;
        *.gz)        gunzip $1      ;;
        *.tar)       tar xf $1      ;;
        *.tbz2)      tar xjf $1     ;;
        *.tgz)       tar xzf $1     ;;
        *.zip)       unzip $1       ;;
        *.Z)         uncompress $1  ;;
        *.7z)        7z x $1        ;;
        *)     echo "'$1' cannot be extracted via extract()" ;;
         esac
     else
         echo "'$1' is not a valid file"
     fi
}

# Quickly search for file
alias qfind="find . -name "
# Find file under the current directory
ff () { /usr/bin/find . -name "$@" ; }
# Find file whose name starts with a given string
ffs () { /usr/bin/find . -name "$@"'*' ; }
# Find file whose name ends with a given string
ffe () { /usr/bin/find . -name '*'"$@" ; }

# find out the pid of a specified process
findPid () { lsof -t -c "$@" ; }

base64decode () { echo; echo "${1}" | base64 -d; echo; }

function trim() {
    local var="$*"

    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"

    echo -n "$var"
}

alias now="date '+%Y-%m-%d %H:%M:%S'"

function meteo() {
  curl -4 "wttr.in/${1:-France}"
}

if [ `uname` != "Darwin" ]; then
  return
fi

# Opens current directory in MacOS Finder
alias f='open -a Finder ./'

# Moves a file to the MacOS trash
trash () { command mv "$@" ~/.Trash ; }
# Opens any file in MacOS Quicklook Preview
ql () { qlmanage -p "$*" >& /dev/null; }

# 'Cd's to frontmost window of MacOS Finder
cdf () {
    currFolderPath=$( /usr/bin/osascript <<EOT
        tell application "Finder"
            try
        set currFolder to (folder of the front window as alias)
            on error
        set currFolder to (path to desktop folder as alias)
            end try
            POSIX path of currFolder
        end tell
EOT
    )
    echo "cd to \"$currFolderPath\""
    cd "$currFolderPath"
}

alias finderRestart='sudo killall Finder >/dev/null 2>&1'
alias finderShowHidden='defaults write com.apple.finder AppleShowAllFiles -bool true && finderRestart'
alias finderHideHidden='defaults write com.apple.finder AppleShowAllFiles -bool false  && finderRestart'

generate_pdf() {
  # Prompt for the number of pages
  read -p "Enter the number of pages [default=1]: " PAGES
  local PAGES=${PAGES:-1}

  # Prompt for the output file name
  read -p "Enter the output file name [default=generated.pdf]: " FILENAME

  # Add pdf extension if not present
  if [[ $FILENAME != *".pdf" ]]; then
    FILENAME="$FILENAME.pdf"
  fi

  # Prompt for the password (if needed)
  read -p "Enter the password [default=none]: " PASSWORD
  local PASSWORD=${PASSWORD:-none}

  # PDF header
  echo "%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [" > $FILENAME

  # Generate page references
  for i in $(seq 4 $((3 + PAGES)))
  do
    echo "$i 0 R " >> $FILENAME
  done

  # Continue PDF header
  echo "] /Count $PAGES >>
endobj" >> $FILENAME

    # Font object
    echo "3 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj" >> $FILENAME

  # Generate pages
  for i in $(seq 4 $((3 + PAGES)))
  do
    CONTENT_INDEX=$((PAGES + i))
    echo "$i 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 595 842] /Resources << /Font << /F1 3 0 R >> >> /Contents $CONTENT_INDEX 0 R >>
endobj" >> $FILENAME
  done

  # Generate contents
  for i in $(seq 1 $PAGES)
  do
    CONTENT_INDEX=$((3 + PAGES + i))
    PAGE_TEXT="Page $i"
    CONTENT="BT /F1 48 Tf 0 0 0 rg 297 421 Td ($PAGE_TEXT) Tj ET"
    CONTENT_LENGTH=${#CONTENT}
    echo "$CONTENT_INDEX 0 obj
<< /Length $CONTENT_LENGTH >>
stream
$CONTENT
endstream
endobj" >> $FILENAME
  done

  # xref table
  echo "xref
0 $((3 + 2 * PAGES))
0000000000 65535 f" >> $FILENAME

  OFFSET=9
  for i in $(seq 1 $((3 + 2 * PAGES)))
  do
    printf "%010d 00000 n\n" $OFFSET >> $FILENAME
    OFFSET=$(($OFFSET + $(awk "NR==$i{print length(\$0)+1}" $FILENAME)))
  done

  # Trailer
  echo "trailer
<< /Size $((3 + 2 * PAGES)) /Root 1 0 R >>
startxref
$OFFSET
%%EOF" >> $FILENAME

if [ "$PASSWORD" != "none" ]; then
  if [ command -v qpdf >/dev/null 2>&1 ]; then
    echo "qpdf is not installed. Please install it to encrypt the PDF."
    return
  fi
  qpdf --encrypt $PASSWORD $PASSWORD 256 -- $FILENAME ${FILENAME%.*}-encrypted.pdf 2>/dev/null 1>&2
  rm $FILENAME
  mv ${FILENAME%.*}-encrypted.pdf $FILENAME
elif [ command -v qpdf >/dev/null 2>&1 ]; then
  qpdf -- $FILENAME ${FILENAME%.*}-cleaned.pdf 2>/dev/null 1>&2
  rm $FILENAME
  mv ${FILENAME%.*}-cleaned.pdf $FILENAME
fi
}
